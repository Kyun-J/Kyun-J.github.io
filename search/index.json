[{"content":"WebView는 계륵이다 WebView를 사용하지 않을 수 없을까?  여러 프로젝트에서 WebView는 껄끄러운 존재입니다. Native의 아키텍쳐와는 별개로 구성하여야 하고, WebView만의 여러 설정법이 있기 때문입니다.. (수많은 버그는 덤이다)\n이런 WebView를 아예 사용하지 않으면 좋겠으나 기획, 마케팅에서 원하는 모든 정보 혹은 UI를 Native 영억에서 100% 컨트롤 할 수 없는 경우가 생기므로, 프로젝트 어딘가 한켠에 WebView를 사용해야 하는 경우가 생기기 마련이니다.\n 진짜 귀찮은 것은 인터페이스 WebView가 정말로 귀찮은 이유는 바로 WebPage와의 Interface입니다.\n대표적인 사항으로 다음과 같은 것들이 있는데,\n Android와 iOS 각각의 Interface구현 방법이 다르다 WebPage상에서 Android, iOS의 Interface 구현체 구조가 서로 다르다. 결과값(Return)을 전달하기가 애매하다.  Android의 JavaScriptBridge는 비동기로 결과값 전달이 불가능하며, Array 및 Map 형태의 데이터를 사용 할 수 없다. iOS의 UserContentController는 결과값을 전달하기 위한 장치를 별도로 구축해야 한다.    이러한 문제점들을 해결 하고자 추가 자원(인적, 시간)이 필연적으로 발생하게 됩니다.\n필자는 프로젝트들을 진행하면서, 이런 문제점들을 해결하고 공통화한 라이브러리를 제작하였습니다.\n라이브러리 소개 링크 - Android용, iOS용\n주요 특징   구조가 유사한 kotlin의 lambda와 swift의 closure을 각각 사용하여, 인터페이스시 동작할 사항을 정의 할 수 있다. WebPage에서의 구현체는 동일하며, 별도의 js파일을 삽입할 필요가 없다. WebVeiw에서 필요한 스크립트를 제작하여 WebPage에 주입한다. 결과값(Return)전달이 가능하고 비동기(WebPage의 Promise 패턴)방식을 통해 인터페이스 된다.   간단 사용법  WebView에 인터페이스를 등록.  /* * Android Kotlin */ val testLambda : FlexLambda.array = { arguments -\u0026gt; // arguments에는 WebPage에서 전달받을 값들이 담겨 있음  arrayOf(1,2,3) // [1,2,3] 배열을 리턴 } // WebView에 testLambda가 동작하는 testInterface 등록 // 첫번째 인자는 WebPage에서 사용할 인터페이스 함수명, // 두번재 인자는 인터페이스 시 동작할 lambda mWebView.arrayInterface(\u0026#34;testInterface\u0026#34;, testLambda) WebPage에서 함수 사용  /* * Android Kotlin */ // WebView에 웹페이지를 로드하는 시점에 WebPage에 인터페이스가 자동으로 등록. mWebView.loadUrl(someUrl) /* * WebPage */ async function test() { // $flex 객체가 WebPage에 자동으로 생성  // WebView에서 등록한 testInterface가 자동으로 $flex의 하위 객체로 생성  // $flex의 인터페이스는 Promise를 리턴  // Android, iOS 모두 동일하여 코드 이원화 할 필요 X  return await $flex.testInterface(); // [1,2,3] } 마무리 해당 라이브러리는 더 많은 추가 기능과 사용법이 있으므로, 관심이 있다면 Repository(Android용, iOS용)에 방문하여 확인 해 주시면 감사드립니다!\n","date":"2021-03-24T12:16:29+09:00","permalink":"https://kyun-j.github.io/p/webview-native-interface-%EA%B0%9C%EC%84%A0-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%86%8C%EA%B0%9C/","title":"WebView \u003c-\u003e Native Interface 개선 라이브러리 소개"},{"content":"Json안의 Obejct와 Array도 Model Class로 사용하고 싶다! 지난 포스트 에서 http 통신의 결과값(Json)을 Model Class로 받는 방법에 대해 설명하였다.\n해당 포스트에선 예시로 단순한 Json 형태를 들었지만, 실제 현장에서는 훨신 복잡한\n(Json 안에 또다른 Object 혹은 Array가 있는) 형태의 Json들을 다루게 된다.\n이런 경우에도 Model Class로 Json의 내용을 치환하여 사용해 보자!\n필요한 Model을 만들자 다음과 같은 Json을 다룬다고 가정해 보자.\n{ id: \u0026#34;user\u0026#34;, name: \u0026#34;I AM USER\u0026#34;, address: [ { name: \u0026#34;home\u0026#34;, detail: { first: \u0026#34;korea\u0026#34;, second: \u0026#34;seoul\u0026#34; }, zipCode: { old: { code: \u0026#34;123456\u0026#34; }, new: { code: \u0026#34;7890\u0026#34; } } } ] } 지난 포스트의 User Model에서 address가 추가된 형태이다.\naddress는 List 형태로서 복수개의 Object를 가질 수 있다.\n각각의 Object는 이름 - name(String), 상세 주소 - detail(Object), 우편번호 - zipCode(Object) 가 있으며,\nzipCode의 각각 항목은 또다른 Object로 구성되어 있다.\n먼저 복잡한 이 Json의 각 항목을 Model로 작성해 보자.\n/// 가장 최상위 User Model class User extends Model { final String id; final String name; final List\u0026lt;Address\u0026gt; address; } /// List 내의 각 주소 Model class Address extends Model { final String name; final Map\u0026lt;String, ZipCode\u0026gt; zipCode; final AddressDetail detail; } /// 상세 주소 Model class AddressDetail extends Model { final String first; final String second; } /// 우편 번호 code Model class ZipCode extends Model { final String code; } 총 3가지의 케이스를 기준으로 Model을 구성하였다.\n Array안의 Object를 다룰 경우 - final List\u0026lt;Address\u0026gt; address; Object를 바로 Model로 다루는 경우 - final AddressDetail detail; Object안의 또다른 Object가 있어, Map으로 다루는 경우 - final Map\u0026lt;String, ZipCode\u0026gt; zipCode;  이어서 Json을 각 Model Class 안에 옮기는 작업을 진행해 보자.\nArray와 Object를 Model로 변환 지난 포스트에선 아래의 함수를 구성하였다.  먼저, toSpecificModel함수에 이번에 새로 추가한 함수들을 Switch조건에 포함시키자.  다음으로 Array -\u0026gt; List\u0026lt;Model\u0026gt;, Object -\u0026gt; Map\u0026lt;String, Model\u0026gt;으로 변환시킬 함수를 제작하자.\n(Object -\u0026gt; Map의 경우에는, toSpecificModel을 사용하면 된다.)\nArray를 List로 변환할 toSpecificModelList 함수  Object를 Map\u0026lt;String, Model\u0026gt;로 변환할 toSpecificModelMap 함수  마지막으로, 각 Model들의 생성자를 구성하자. 이때, 각 Model이 포함 할 또다른 Model들을 위에 구성한 함수들을 사용하여(중요) 생성하도록 하자!  테스트 지난 포스트의 response를\n{ id: \u0026#34;user\u0026#34;, name: \u0026#34;I AM USER\u0026#34;, address: [ { name: \u0026#34;home\u0026#34;, detail: { first: \u0026#34;korea\u0026#34;, second: \u0026#34;seoul\u0026#34; }, zipCode: { old: { code: \u0026#34;123456\u0026#34; }, new: { code: \u0026#34;7890\u0026#34; } } } ] } 로 변경하고 getNewUser 함수를 아래와 같이 수정하여 테스트를 진행하자.\nFuture\u0026lt;User?\u0026gt; getNewUser() async { Res\u0026lt;User\u0026gt; res = await _api.post\u0026lt;User\u0026gt;(url: \u0026#34;/getUser\u0026#34;); final user = res.data; // 유저 데이터  final firstAddress = user?.address[0]; // Address Model  final firstAddressName = firstAddress?.name; // Address Model의 name 상수  final oldZipcode = firstAddress?.zipCode[\u0026#34;old\u0026#34;]; // zipCode Object의 \u0026#34;old\u0026#34; Object  final firstAddressDetail = firstAddress?.detail; // Address Model의 detail Model  print(\u0026#34;message: ${res.message}\u0026#34;); // \u0026#34;success!!\u0026#34;  print(\u0026#34;serverCode: ${res.serverCode}\u0026#34;); // 100  print(\u0026#34;statusCode: ${res.statusCode}\u0026#34;); // 200  print(\u0026#34;addressName: $firstAddressName\u0026#34;); // home  print(\u0026#34;addressDetail: ${firstAddressDetail?.first}\u0026#34;); // korea  print(\u0026#34;oldZipCode: ${oldZipcode?.code}\u0026#34;); // 123456  print(\u0026#34;isSuccess: ${res.isSuccess}\u0026#34;); // true  print(\u0026#34;isException: ${res.isException}\u0026#34;); // false  return res.data; } 콘솔 창에 아래와 같이 출력될 것 이다.\nmessage: success!! serverCode: 100 statusCode: 200 addressName: home addressDetail: korea oldZipCode: 123456 isSuccess: true isException: false 마무리 Reflection을 할 수 있는 dart:mirror 라이브러리를 활용하면, GsonConverter와 같이 자동으로 Json의 내용을 Model Class의 구조에 맞게 담아주게 구성 할 수 있을것이다.\n하지만, Reflection을 하지 않고도 Dart의 문법만으로도 충분히 실 사용이 가능할 정도(크게 러닝커브가 크지 않으면서) Json을 Model class로 사용 할 수 있도록 구성 해 보았다.\n다음 포스트에는 Web과 Native의 플랫폼별 인터페이스를, 동일한 구조로 사용하는 과정을 포스트해 보도록 하겠다.\n","date":"2021-03-17T16:43:55+09:00","permalink":"https://kyun-j.github.io/p/flutter-json%EC%95%88%EC%9D%98-object%EC%99%80-array%EB%8F%84-model%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90/","title":"(Flutter) Json안의 Object와 Array도 Model로 사용하자"},{"content":"Flutter의 http통신을 아름답게 사용 할 수 없을까?  Retroift같이 Model을 베이스로 한 통신을 구성 할 수 없을까?\n자연스러운 비동기 통신을 구성 할 순 없을까?\n서드파티 라이브러리를 사용하지 않고, 기본 기능과 문법으로 구성해 볼 수 있지 않을까?\n Flutter를 사용하다보니 이와 같은 생각이 들었다.\nDart의 아래 특징을 사용하면 충분히 가능할거란 판단이 들어 시도를 해 보았다.\n Generic이 있다. (즉, 타입 체크 및 Model만의 공통 기능 사용이 가능하다.) factory를 통해 Constructor를 커스텀 할 수 있다. json(String)을 Map으로 Convert할 수 있는 기능이 있다. 비동기 작업을 위한 기능(Future)가 있다.  기본 Model클래스 생성 모든 Model객체의 부모가 될 Model 클래스를 생성하자.\nclass Model {} Model클래스는 일단 아무런 기능이 필요 없다. 모든 Model객체는 Model클래스를 extends 할 것이고, 이를 통해 1차 타입 체크를 할 것이다.\n추가로, 모든 Model객체들에게 공통적인 기능이 필요하다면 해당 클래스에 구현하면 된다.\n서버로부터 기본(공통)적인 정보를 저장할 Res 클래스 서버로부터 단순히 요청의 데이터만 받는 경우는 드물다.\n응답코드, 응답메시지, 에러코드 등 여러 추가적인 정보를 포함 할 Res 클래스를 생성하자.\n 이때, 서버로부터 전달 받을 데이터를 Model객체로 하며 Generic을 통해 원하는 모델을 전달받고 타입 검증을 할 수 있도록 구성하자.\n실제 사용할 Model클래스 생성 실제 데이터를 포함할 간단한 Model을 생성하자.  factory를 통해 새로운 생성자를 만들고, Map을 전달하면 자동으로 클래스를 생성하도록 구성하자.\n또한 새로운 Model 클래스를 구성할 때에도 동일하게 Map으로 객체를 생성할 수 있는 구조를 만들자.\nMap을 특정 Model로 변환 각 Model의 factory 생성자 호출하여 Map을 Model로 변환할 함수를 하나 만들도록 하자.  위 함수는 아래와 같이 사용할 수 있을 것 이다.\nUser myUser = toSpecificModel\u0026lt;User\u0026gt;(jsonMap); http 통신하여 Model에 담기 이제 본격적으로 http통신을 하여 Model로 받아보도록 하자.\n먼저 기본적으로 다음의 라이브러리가 필요하다.\n(Dart 개발 팀 공식 라이브러리)\nimport \u0026#39;package:http/http.dart\u0026#39;; import \u0026#39;dart:convert\u0026#39;; 위 라이브러리를 추가하면 Client()함수로 http Client객체를 생성할 수 있고, json.decode(String resource)함수를 통해 Json형태의 String을 Map으로 변환할 수 있다.\n(http.dart의 response body는 byte 혹은 String으로만 전달 받을 수 있기 때문.)\n그 후 Api클래스를 아래와 같이 구성하자.  차근차근 뜯어보자 Api클래스의 get 함수를 분석해보자.   client 객체의 리턴은 비동기(Future)를 통해 전달된다.  따라서 get 함수 또한, async await를 구성하고 Future를 리턴하도록 구성.   Future는 특정 Model을 담은 Res객체를 반환하도록 구성. 공통 함수(_genRes, _genUri, genDefaultHeaders) 생성  기타 http 및 Rest Method(delete, post, put \u0026hellip;)에서도 공통적으로 사용할 기능이기에 분리    genRes genRes함수에는 중요 기능들이 포함되어 있다.  json.decode를 통해 response의 body를 Map으로 변환 후, 먼저 선언하였던 toSepcificModel 함수를 통해 원하는 Model로 Map을 변환하여 최종적으로 Model이 포함된 결과값을 받게 된다!\n정리하면\u0026hellip; 현재까지 진행사항을 통해, 아래와 같이 http통신을 하고 User Model을 결과값으로 전달 받을 수 있다.  하지만 아직 부족하다! 여기까지 진행해도 Model을 사용한 통신 구성에 문제는 없지만, Dart의 mixin을 활용하여 좀 더 고급스럽게 사용해 보자.\nmixin 클래스 생성  먼저, Res객체가 아닌 Model 자체를 반환받도록 한번 더 함수로 감싸자.\n그리고 mixin이기 때문에, 아래와 같이 실 사용이 가능하다.\n최종 결과  상태 변경에따라 Widget을 빌드하는 클래스인 _MyHomePageState 클래스에 with UserApi를 추가하여, UserApi mixin에 선언한 함수를 바로 사용 할 수 있게 되었다.\n이제 _addUser()를 호출할 때마다 리스트에 새로운 User Model이 서버와의 통신을 통해 추가되고, 이를 활용해 여러 작업(리스트를 추가한다던지\u0026hellip;)이 가능할 것이다!\n마무리\u0026hellip; Retrofit과 유사하게 http 통신을 하도록 구성해 보았습니다.\n이 포스트에는 응답 부분만 다루었지만, 조금만 수정하면 Request도 충분히 Model을 통해 사용할 수 있을 것입니다.\n","date":"2021-03-15T13:15:51+09:00","permalink":"https://kyun-j.github.io/p/flutter-model%EC%9D%84-%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%A1%9C-%ED%95%9C-http%ED%86%B5%EC%8B%A0%EC%9D%84-%EA%B5%AC%EC%84%B1%ED%95%B4-%EB%B3%B4%EC%9E%90/","title":"(Flutter) Model을 베이스로 한 http통신을 구성해 보자"}]